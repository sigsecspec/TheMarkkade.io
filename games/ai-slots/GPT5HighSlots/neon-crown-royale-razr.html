<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Neon Crown Royale — GPT-5 HIGH Edition</title>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Emoji", sans-serif;
      background: radial-gradient(120% 120% at 50% -10%, #243B55 0%, #141E30 35%, #0B1220 100%);
      color: #fff;
      overflow: hidden;
    }

    /* Dual-screen layout for Razr: top = display, bottom = controls */
    .razr {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }
    .top {
      height: 50vh;
      position: relative;
      overflow: hidden;
      background: linear-gradient(160deg, #0F172A 0%, #111827 60%, #000 100%);
      border-bottom: 3px solid #ffcf40;
    }
    .bottom {
      height: 50vh;
      background: linear-gradient(160deg, #0A0F1E 0%, #0E1526 60%, #0B1120 100%);
      display: flex;
      flex-direction: column;
      padding: 14px env(safe-area-inset-right) calc(10px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
      gap: 14px;
    }

    /* Cabinet frame */
    .cabinet {
      position: absolute;
      inset: 10px 10px 10px 10px;
      border-radius: 20px;
      background: linear-gradient(180deg, #1a1a1a 0%, #0d0d0d 100%);
      box-shadow: inset 0 0 28px rgba(0,0,0,0.6), 0 0 24px rgba(255,215,0,0.25);
      border: 4px solid #ffcf40;
    }
    .marquee {
      position: absolute; left: 50%; top: 10px; transform: translateX(-50%);
      display: flex; align-items: center; gap: 10px;
      padding: 8px 16px;
      border-radius: 999px;
      background: radial-gradient(120% 180% at 50% 0%, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      box-shadow: 0 0 24px rgba(255, 183, 0, 0.25);
      border: 1px solid rgba(255, 207, 64, 0.35);
    }
    .marquee .crown {
      font-size: 1.5rem;
      filter: drop-shadow(0 0 8px rgba(255,215,0,0.8));
    }
    .marquee .title {
      font-weight: 800;
      letter-spacing: .5px;
      text-transform: uppercase;
      color: #ffef9a;
      text-shadow: 0 0 18px rgba(255,215,0,0.7), 0 2px 0 rgba(0,0,0,0.6);
      white-space: nowrap;
    }

    /* Reel window */
    .reels-window {
      position: absolute; left: 50%; top: 62px; transform: translateX(-50%);
      width: min(92vw, 680px);
      height: calc(100% - 62px - 115px);
      border: 3px solid #ffcf40;
      border-radius: 14px;
      background: linear-gradient(180deg, #111 0%, #060606 100%);
      box-shadow: inset 0 0 30px rgba(0,0,0,0.75);
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 8px; padding: 10px; overflow: hidden;
    }
    .reel {
      position: relative;
      border-radius: 10px;
      background: linear-gradient(180deg, #1f2937, #111827);
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
      overflow: hidden;
      height: 100%;
    }
    .strip { position: absolute; width: 100%; will-change: transform; }
    .symbol {
      height: 86px; display: flex; align-items: center; justify-content: center;
      font-size: 2.6rem; line-height: 1;
      background: linear-gradient(180deg, #f7f7f7, #dfe3ea);
      border-bottom: 1px solid rgba(0,0,0,0.15);
      color: #0b0f1a; text-shadow: 0 1px 0 #fff;
    }

    /* Payline overlay */
    .paylines { pointer-events: none; position: absolute; inset: 0; }
    .payline {
      position: absolute; left: 10px; right: 10px; height: 3px; border-radius: 2px;
      background: linear-gradient(90deg, transparent, #ff3b30, #ff3b30, transparent);
      box-shadow: 0 0 10px rgba(255,59,48,0.8);
      opacity: 0; transition: opacity .25s ease;
    }
    .payline.middle { top: 50%; transform: translateY(-50%); }
    .payline.top { top: calc(10px + 86px * 0 + 86px/2); }
    .payline.bottom { top: calc(10px + 86px * 2 + 86px/2); }
    .payline.diag1, .payline.diag2 { height: 0; border-top: 3px dashed #ff3b30; box-shadow: none; }
    .payline.diag1 { top: calc(10px + 86px/2); transform: skewY(18deg); }
    .payline.diag2 { top: calc(10px + 86px * 2 + 86px/2); transform: skewY(-18deg); }

    /* Info panel */
    .info {
      position: absolute; left: 50%; bottom: 12px; transform: translateX(-50%);
      width: min(92vw, 680px); height: 92px;
      background: linear-gradient(180deg, #0b0f1a, #0b1220);
      border: 2px solid #ffcf40; border-radius: 12px;
      display: grid; grid-template-columns: repeat(4, 1fr);
      align-items: center; justify-items: center;
      color: #ffef9a; font-weight: 800;
      text-shadow: 0 0 12px rgba(255,215,0,0.55);
    }
    .info .label { font-size: 0.7rem; color: #c2c2c2; font-weight: 700; letter-spacing: .35px; }
    .info .value { font-size: 1.4rem; color: #ffef9a; }

    /* Glass glare + touch effects */
    .glass {
      position: absolute; inset: 0; pointer-events: none;
      background: linear-gradient( 160deg, rgba(255,255,255,0.06), rgba(255,255,255,0.01) 30%, transparent 60% );
      mix-blend-mode: screen;
    }
    .touch-ripple { position: absolute; width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.5); transform: scale(0); animation: ripple .6s linear forwards; pointer-events: none; }
    @keyframes ripple { to { transform: scale(4); opacity: 0; } }
    .sparkle { position: absolute; width: 9px; height: 9px; background: #fff; border-radius: 50%; box-shadow: 0 0 14px #fff; pointer-events: none; }

    /* Win / Jackpot overlays */
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; z-index: 8; }
    .overlay.win { background: rgba(255,215,0,0.08); }
    .win-text { font-size: 3rem; font-weight: 900; color: #ffef9a; text-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700; animation: pulse 1s ease-in-out infinite; text-align: center; white-space: pre-line; }
    @keyframes pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.1);} }

    .overlay.jackpot { position: fixed; background: rgba(255,0,0,0.86); z-index: 999; animation: flash .5s ease-in-out infinite; }
    @keyframes flash { 0%,100%{ background: rgba(255,0,0,0.86);} 50%{ background: rgba(255,215,0,0.86);} }
    .jackpot-text { font-size: 4rem; font-weight: 900; color: #fff; text-shadow: 0 0 40px #fff, 0 0 80px #ffd700; }

    /* LED bezel */
    .leds { position: absolute; inset: 6px; pointer-events: none; display: grid; grid-template-columns: repeat(24, 1fr); grid-auto-rows: 6px; gap: 2px; opacity: 0.85; }
    .led { background: radial-gradient(circle at 40% 40%, #ffe082, #ffb300 60%, #8a6b00 100%); border-radius: 50%; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.6)); opacity: 0.35; animation: ledBlink 2.2s ease-in-out infinite; }
    .led:nth-child(odd){ animation-delay: .7s; }
    @keyframes ledBlink { 0%, 100% { opacity: .35 } 50% { opacity: .9 } }

    /* Controls */
    .rows { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .rows.two { grid-template-columns: repeat(2, 1fr); }
    .btn {
      height: 64px; border: none; border-radius: 16px; font-size: 1.05rem; font-weight: 900; letter-spacing: .3px; color: #fff; cursor: pointer; position: relative; overflow: hidden;
      box-shadow: 0 6px 0 rgba(0,0,0,0.6), 0 10px 20px rgba(0,0,0,0.35);
      transition: transform .15s ease, box-shadow .15s ease; user-select: none;
    }
    .btn:active { transform: translateY(3px); box-shadow: 0 3px 0 rgba(0,0,0,0.6), 0 6px 12px rgba(0,0,0,0.35); }
    .btn.spin { grid-column: 1 / -1; height: 84px; font-size: 1.25rem; border-radius: 20px; background: linear-gradient(180deg, #ef4444, #b91c1c); box-shadow: 0 8px 0 #7f1d1d, 0 16px 26px rgba(0,0,0,0.5); }
    .btn.blue { background: linear-gradient(180deg, #3b82f6, #1d4ed8); }
    .btn.gold { background: linear-gradient(180deg, #f59e0b, #b45309); }
    .btn.green { background: linear-gradient(180deg, #22c55e, #15803d); }

    .meta {
      margin-top: 2px; text-align: center; font-size: .72rem; color: #9aa3b2;
      background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px; padding: 8px;
    }
    .credit { opacity: .85; }

    /* Paytable modal */
    .modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); z-index: 50; }
    .modal-card { width: min(92vw, 720px); max-height: 80vh; overflow: auto; background: #0b1220; border: 2px solid #ffcf40; border-radius: 16px; padding: 16px; box-shadow: 0 30px 60px rgba(0,0,0,0.35); }
    .modal-card h3 { margin: 0 0 8px 0; color: #ffef9a; }
    .paytable { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }
    .pt-row { background: linear-gradient(180deg,#0f172a,#0a0f1e); border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; padding: 10px; display: flex; align-items: center; justify-content: space-between; }
    .pt-sym { font-size: 1.6rem; }
    .pt-pay { color: #cdd6f4; font-weight: 700; }

    @media (max-width: 480px) {
      .symbol { height: 78px; font-size: 2.3rem; }
      .info .value { font-size: 1.2rem; }
      .btn { height: 56px; }
      .btn.spin { height: 74px; }
    }
  </style>
</head>
<body>
  <!-- Loading -->
  <div id="loading" style="position:fixed;inset:0;display:flex;flex-direction:column;gap:18px;align-items:center;justify-content:center;background:linear-gradient(180deg,#0b1120,#0a0f1e);z-index:9999;">
    <div style="font-size:1.6rem;font-weight:900;color:#ffef9a;text-shadow:0 0 22px #ffd700;">👑 Neon Crown Royale</div>
    <div style="width:280px;height:10px;background:#1f2937;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.08);">
      <div id="loadingBar" style="height:100%;width:0%;background:linear-gradient(90deg,#ffd700,#fff382);box-shadow:0 0 12px #ffd700;"></div>
    </div>
    <div id="loadingText" style="color:#a1a1aa;font-weight:600;">Warming up the reels…</div>
  </div>

  <div class="razr" id="app" style="display:none;">
    <!-- TOP: Display only (tap-able for effects) -->
    <section class="top" id="topScreen">
      <div class="cabinet">
        <div class="marquee">
          <span class="crown">👑</span>
          <span class="title">Neon Crown Royale — GPT-5 HIGH</span>
        </div>

        <div class="reels-window">
          <div class="reel"><div class="strip" id="strip0"></div></div>
          <div class="reel"><div class="strip" id="strip1"></div></div>
          <div class="reel"><div class="strip" id="strip2"></div></div>

          <div class="paylines">
            <div class="payline top" id="payTop"></div>
            <div class="payline middle" id="payMid"></div>
            <div class="payline bottom" id="payBot"></div>
            <div class="payline diag1" id="payD1" style="left:10px;right:10px;"></div>
            <div class="payline diag2" id="payD2" style="left:10px;right:10px;"></div>
          </div>
        </div>

        <div class="info">
          <div>
            <div class="label">CREDITS</div>
            <div class="value" id="credits">1000</div>
          </div>
          <div>
            <div class="label">BET</div>
            <div class="value" id="bet">10</div>
          </div>
          <div>
            <div class="label">LINES</div>
            <div class="value" id="lines">5</div>
          </div>
          <div>
            <div class="label">WIN</div>
            <div class="value" id="win">0</div>
          </div>
        </div>

        <div class="glass"></div>
        <div class="overlay win" id="winOverlay"><div class="win-text" id="winText">BIG WIN!\n$0</div></div>
      </div>

      <div class="leds" aria-hidden="true" id="ledGrid"></div>
    </section>

    <!-- Bottom: Controls -->
    <section class="bottom">
      <div class="rows">
        <button class="btn blue" id="betDown">➖ BET</button>
        <button class="btn gold" id="maxBet">🔥 MAX BET</button>
        <button class="btn blue" id="betUp">➕ BET</button>
      </div>
      <div class="rows">
        <button class="btn blue" id="linesDown">➖ LINES</button>
        <button class="btn green" id="cashOut">💸 CASH OUT</button>
        <button class="btn blue" id="linesUp">➕ LINES</button>
      </div>
      <button class="btn spin" id="spin">🎰 SPIN TO WIN</button>
      <div class="rows two">
        <button class="btn blue" id="auto">🔄 AUTO</button>
        <button class="btn gold" id="paytable">📊 PAYTABLE</button>
      </div>
      <div class="meta credit">Created by GPT-5 HIGH</div>
    </section>
  </div>

  <!-- Jackpot overlay -->
  <div class="overlay jackpot" id="jackpot"><div class="jackpot-text">🎉 JACKPOT! 🎉</div></div>

  <!-- Paytable Modal -->
  <div class="modal" id="paytableModal">
    <div class="modal-card">
      <h3>🎰 Pay Table</h3>
      <div class="paytable" id="paytableGrid"></div>
      <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn green" id="closePaytable" style="height:48px; padding:0 14px;">Close</button>
      </div>
    </div>
  </div>

  <script>
    class NeonCrownRoyale {
      constructor() {
        // Economic state
        this.credits = Number(localStorage.getItem('g5h_credits')) || 1000;
        this.betLevels = [5, 10, 25, 50, 100, 250];
        this.betIndex = 1; // 10
        this.lines = 5; // 1..5
        this.lastWin = 0;

        // Game state
        this.isSpinning = false;
        this.autoSpinsRemaining = 0;

        // Symbol set with payout multipliers (per line, for 3 of a kind)
        // Wild ⭐ substitutes any non-special symbol. Free spins 🆓 and Bonus 🎁 are scatters (anywhere).
        this.symbols = [
          { key: 'CHERRY', char: '🍒', weight: 28, pay3: 8, color: '#ff4d6d' },
          { key: 'LEMON',  char: '🍋', weight: 24, pay3: 10, color: '#ffd166' },
          { key: 'GRAPE',  char: '🍇', weight: 20, pay3: 14, color: '#a78bfa' },
          { key: 'BELL',   char: '🔔', weight: 14, pay3: 24, color: '#f59e0b' },
          { key: 'SEVEN',  char: '7️⃣', weight: 9, pay3: 48, color: '#ef4444' },
          { key: 'DIAM',   char: '💎', weight: 6, pay3: 120, color: '#60a5fa' },
          { key: 'CROWN',  char: '👑', weight: 4, pay3: 240, color: '#ffef9a' },
          { key: 'WILD',   char: '⭐', weight: 5, pay3: 150, color: '#fef08a', wild: true },
          { key: 'BONUS',  char: '🎁', weight: 2, pay3: 0, color: '#34d399', bonus: true },
          { key: 'FSPIN',  char: '🆓', weight: 2, pay3: 0, color: '#93c5fd', freespin: true },
        ];

        this.reelCount = 3;
        this.rowsVisible = 3;
        this.stripLength = 48; // long for realism
        this.reelStrips = []; // array per reel of chars

        this.paylines = [
          [1,1,1], // middle
          [0,0,0], // top
          [2,2,2], // bottom
          [0,1,2], // diag down
          [2,1,0], // diag up
        ];

        // Audio
        this.audioContext = null;
        this.sounds = {};

        // DOM refs
        this.$ = (id) => document.getElementById(id);

        this.init();
      }

      async init() {
        await this.fakeLoader();
        this.mountUI();
        this.initAudio();
        this.buildReelStrips();
        this.renderStrips();
        this.renderPaytable();
        this.updateInfo();
        this.seedLEDs();
      }

      async fakeLoader(){
        const steps = [
          'Calibrating RNG…',
          'Lubricating reels…',
          'Tuning neon glow…',
          'Arming haptics…',
          'Sound-check…',
          'Finalizing cabinet…',
        ];
        for (let i=0;i<steps.length;i++){
          this.$('loadingText').textContent = steps[i];
          this.$('loadingBar').style.width = ((i+1)/steps.length*100).toFixed(1)+'%';
          await this.delay(220 + Math.random()*180);
        }
        setTimeout(()=>{
          this.$('loading').style.opacity='0';
          this.$('loading').style.transition='opacity .4s ease';
          setTimeout(()=>{
            this.$('loading').style.display='none';
            this.$('app').style.display='flex';
            this.$('app').style.opacity='0';
            this.$('app').style.transition='opacity .4s ease';
            setTimeout(()=>{ this.$('app').style.opacity='1'; }, 50);
          }, 420);
        }, 200);
      }

      mountUI(){
        // Buttons
        this.$('betDown').addEventListener('click', ()=>{ this.changeBet(-1); this.hap([30]); this.play('btn'); });
        this.$('betUp').addEventListener('click', ()=>{ this.changeBet(1); this.hap([30]); this.play('btn'); });
        this.$('maxBet').addEventListener('click', ()=>{ this.maxBet(); this.hap([60]); this.play('btnHi'); });
        this.$('linesDown').addEventListener('click', ()=>{ this.changeLines(-1); this.hap([30]); this.play('btn'); });
        this.$('linesUp').addEventListener('click', ()=>{ this.changeLines(1); this.hap([30]); this.play('btn'); });
        this.$('cashOut').addEventListener('click', ()=>{ this.cashOut(); this.hap([200,80,200]); this.play('cash'); });
        this.$('spin').addEventListener('click', ()=> this.trySpin());
        this.$('auto').addEventListener('click', ()=> this.toggleAuto());
        this.$('paytable').addEventListener('click', ()=>{ this.showPaytable(true); this.play('open'); });
        this.$('closePaytable').addEventListener('click', ()=>{ this.showPaytable(false); this.play('close'); });

        // Top screen effects
        const top = this.$('topScreen');
        top.addEventListener('pointerdown', (e)=>{
          this.touchRipple(top, e);
          this.sparkles(top, e);
          this.hap([40,30,40]);
          this.play('tap');
        });

        // Prevent context menu / double-tap zoom
        document.addEventListener('contextmenu', e=>e.preventDefault());
        let lastTouchEnd=0; document.addEventListener('touchend', e=>{ const now=Date.now(); if(now-lastTouchEnd<350) e.preventDefault(); lastTouchEnd=now; }, {passive:false});
      }

      initAudio(){
        const resume = async () => {
          try{
            if(!this.audioContext){ this.audioContext = new (window.AudioContext||window.webkitAudioContext)(); }
            if(this.audioContext.state==='suspended'){ await this.audioContext.resume(); }
          }catch{}
        };
        const unlock = ()=>{
          document.removeEventListener('pointerdown', unlock);
          resume();
        };
        document.addEventListener('pointerdown', unlock, { once:true });

        this.sounds = {
          btn: ()=> this.tone(330, .05, 'square', .12),
          btnHi: ()=> this.tone(660, .08, 'square', .18),
          tap: ()=> this.noise(.06, .12),
          spin: ()=> this.sweep(220, 140, .22, 'sawtooth', .1),
          tick: ()=> this.tone(120, .02, 'sawtooth', .06),
          stop: ()=> this.tone(90, .05, 'triangle', .18),
          win: ()=> this.arpeggio([440,660,880], .12, 'sine', .12),
          big: ()=> this.arpeggio([660,880,1320], .18, 'sine', .16),
          jack: ()=> this.arpeggio([880,1320,1760,1320,880], .2, 'sine', .2),
          cash: ()=> this.noise(.22, .18),
          open: ()=> this.tone(520, .1, 'sine', .14),
          close: ()=> this.tone(300, .08, 'sine', .12),
        };
      }

      // WebAudio helpers
      ctx(){ return this.audioContext; }
      gain(node, v, t){ node.gain.setValueAtTime(v, this.ctx().currentTime + (t||0)); }
      tone(freq, dur, type='sine', vol=.12){
        if(!this.ctx()) return;
        const o=this.ctx().createOscillator(); const g=this.ctx().createGain();
        o.type=type; o.frequency.setValueAtTime(freq, this.ctx().currentTime);
        o.connect(g); g.connect(this.ctx().destination);
        this.gain(g, vol, 0); g.gain.exponentialRampToValueAtTime(0.001, this.ctx().currentTime + dur);
        o.start(); o.stop(this.ctx().currentTime + dur);
      }
      sweep(f1,f2,dur,type='sine',vol=.12){
        if(!this.ctx()) return;
        const o=this.ctx().createOscillator(); const g=this.ctx().createGain();
        o.type=type; o.frequency.setValueAtTime(f1, this.ctx().currentTime); o.frequency.linearRampToValueAtTime(f2, this.ctx().currentTime+dur);
        o.connect(g); g.connect(this.ctx().destination);
        this.gain(g, vol, 0); g.gain.exponentialRampToValueAtTime(0.001, this.ctx().currentTime + dur);
        o.start(); o.stop(this.ctx().currentTime + dur);
      }
      noise(dur, vol=.1){
        if(!this.ctx()) return;
        const buffer = this.ctx().createBuffer(1, this.ctx().sampleRate*dur, this.ctx().sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * 0.7; }
        const src = this.ctx().createBufferSource(); src.buffer = buffer;
        const g=this.ctx().createGain(); src.connect(g); g.connect(this.ctx().destination);
        this.gain(g, vol, 0); g.gain.exponentialRampToValueAtTime(0.001, this.ctx().currentTime + dur);
        src.start();
      }
      arpeggio(freqs, stepDur, type='sine', vol=.12){ if(!this.ctx()) return; freqs.forEach((f,i)=> setTimeout(()=> this.tone(f, stepDur, type, vol), i*stepDur*1000)); }

      hap(pattern){ if(navigator.vibrate) navigator.vibrate(pattern); }

      buildReelStrips(){
        // Create a weighted bag for selection
        const bag = [];
        this.symbols.forEach(s => { for(let i=0;i<s.weight;i++) bag.push(s.char); });
        const pick = ()=> bag[Math.floor(Math.random()*bag.length)];
        this.reelStrips = new Array(this.reelCount).fill(0).map(()=> Array.from({length:this.stripLength}, pick));
      }

      renderStrips(){
        for (let r=0; r<this.reelCount; r++){
          const stripEl = this.$('strip'+r);
          stripEl.innerHTML = '';
          // Duplicate sequence several times to ensure seamless spinning
          const loops = 4;
          for (let k=0; k<loops; k++){
            for (let i=0;i<this.reelStrips[r].length;i++){
              const d = document.createElement('div');
              d.className = 'symbol';
              d.textContent = this.reelStrips[r][i];
              stripEl.appendChild(d);
            }
          }
        }
      }

      updateInfo(){
        this.$('credits').textContent = this.credits.toLocaleString();
        this.$('bet').textContent = this.betLevels[this.betIndex].toLocaleString();
        this.$('lines').textContent = this.lines;
        this.$('win').textContent = this.lastWin.toLocaleString();
        localStorage.setItem('g5h_credits', String(this.credits));
      }

      changeBet(delta){
        this.betIndex = Math.min(this.betLevels.length-1, Math.max(0, this.betIndex + delta));
        this.updateInfo();
      }
      maxBet(){ this.betIndex = this.betLevels.length-1; this.lines = this.paylines.length; this.updateInfo(); this.toast(`Max bet: $${this.betLevels[this.betIndex]} on ${this.lines} lines`); }
      changeLines(delta){ this.lines = Math.min(this.paylines.length, Math.max(1, this.lines + delta)); this.updateInfo(); }

      cashOut(){ if(this.credits>0){ this.toast(`Cashed out $${this.credits}!`); this.credits = 1000; this.updateInfo(); } else { this.toast('No credits to cash out.'); } }

      toggleAuto(){
        if(this.autoSpinsRemaining>0){ this.autoSpinsRemaining = 0; this.$('auto').textContent = '🔄 AUTO'; this.toast('Auto play stopped'); return; }
        this.autoSpinsRemaining = 15;
        this.$('auto').textContent = '⏹️ STOP AUTO';
        this.toast('Auto play: 15 spins');
        if(!this.isSpinning) this.trySpin();
      }

      trySpin(){
        if(this.isSpinning) return;
        const bet = this.betLevels[this.betIndex] * this.lines;
        if(this.credits < bet){ this.toast('Insufficient credits'); this.hap([240,100,240]); return; }
        this.spin();
      }

      async spin(){
        this.isSpinning = true;
        const totalBet = this.betLevels[this.betIndex] * this.lines;
        this.credits -= totalBet; this.lastWin = 0; this.updateInfo();
        this.hap([100, 60, 100]); this.play('spin');

        // Start spinning CSS animation via class + timed stop
        const strips = [this.$('strip0'), this.$('strip1'), this.$('strip2')];
        strips.forEach(el => el.classList.add('spinning'));
        // Provide visual motion by keyframes (we'll emulate with JS ticks for sound)
        const tickTimer = setInterval(()=> this.play('tick'), 110);

        // Determine outcomes per reel (symbols for each visible row center=payline row 1)
        const outcome = this.chooseOutcome();

        // Stop reels one by one with target offsets
        const durations = [2000, 2500, 3000];
        for (let r=0; r<this.reelCount; r++){
          setTimeout(()=>{
            strips[r].classList.remove('spinning');
            // Compute transform so that the middle row shows outcome[r][1]
            this.positionReel(r, outcome[r][1]);
            this.hap([80]); this.play('stop');
            if(r===this.reelCount-1){
              clearInterval(tickTimer);
              setTimeout(()=> this.resolveSpin(outcome, totalBet), 300);
            }
          }, durations[r]);
        }
      }

      // Deterministic positioning: find a matching symbol cell and align middle row on it
      positionReel(reelIndex, symbol){
        const stripEl = this.$('strip'+reelIndex);
        const cells = stripEl.querySelectorAll('.symbol');
        let target = -1;
        for (let i=0; i<cells.length; i++) if(cells[i].textContent === symbol){ target = i; break; }
        if(target>=0){
          const cellH = 86; // must match CSS
          // Offset so the chosen symbol lands on the middle viewing row (row index 1) within the window
          const offset = -(target*cellH) + cellH * 1; // center row
          stripEl.style.transition = 'transform .35s cubic-bezier(.22,1,.36,1)';
          stripEl.style.transform = `translateY(${offset}px)`;
        }
      }

      chooseOutcome(){
        // Build weighted list again (fast enough for small arrays)
        const bag = []; this.symbols.forEach(s=>{ for(let i=0;i<s.weight;i++) bag.push(s.char); });
        const pick = ()=> bag[Math.floor(Math.random()*bag.length)];
        // For each reel, choose 3 consecutive window symbols around a random index
        const out = [];
        for (let r=0; r<this.reelCount; r++){
          const center = pick();
          // Surrounding cells random as well
          const above = bag[Math.floor(Math.random()*bag.length)];
          const below = bag[Math.floor(Math.random()*bag.length)];
          out.push([above, center, below]);
        }
        return out; // [reel][row]
      }

      resolveSpin(outcome, totalBet){
        const paylines = this.paylines.slice(0, this.lines);
        // Build a grid [row][reel]
        const grid = [0,1,2].map(row => outcome.map(col => col[row]));

        // Win calculation
        let win = 0;
        let bestKind = '';
        let jackpot = false;

        for (let i=0; i<paylines.length; i++){
          const line = paylines[i];
          const lineSyms = line.map((row, reel)=> grid[row][reel]);
          const res = this.evaluateLine(lineSyms);
          if(res.amount>0){ win += res.amount * this.betLevels[this.betIndex]; bestKind = res.kind || bestKind; if(res.jackpot) jackpot = true; }
        }

        // Scatters anywhere (BONUS / FSPIN)
        const flat = outcome.flat();
        const count = (ch) => flat.filter(s=>s===ch).length;
        if(count('🎁')>=3){ // bonus
          const bonusWin = (8 + Math.floor(Math.random()*42)) * this.betLevels[this.betIndex];
          win += bonusWin; bestKind = bestKind || 'BONUS';
        }
        if(count('🆓')>=3){ // free spins
          this.toast('Free Spins triggered: 8 spins @2x!');
          this.autoSpinsRemaining = Math.max(this.autoSpinsRemaining, 8);
          // Apply simple multiplier for the next resolve pass
          this._tempMultiplier = 2; setTimeout(()=> delete this._tempMultiplier, 3000);
        }

        // Apply temporary multiplier if set
        if(this._tempMultiplier) win *= this._tempMultiplier;

        this.lastWin = Math.floor(win);
        this.credits += this.lastWin;
        this.updateInfo();

        // Visuals
        if(this.lastWin>0){
          if(jackpot){ this.overlayJackpot(); this.play('jack'); this.hap([220,100,220,100,220,100,220]); }
          else if(this.lastWin >= totalBet*6){ this.overlayWin(`🎉 BIG WIN!\n$${this.lastWin.toLocaleString()}`); this.play('big'); this.hap([160,60,160,60,160]); this.coinRain(Math.min(24, Math.ceil(this.lastWin/50))); }
          else { this.overlayWin(`WIN!\n$${this.lastWin.toLocaleString()}`); this.play('win'); this.hap([120,50,120]); this.coinRain(Math.min(16, Math.ceil(this.lastWin/60))); }
          this.flashPaylines(true);
          setTimeout(()=> this.flashPaylines(false), 1800);
        } else {
          this.hap([60]);
        }

        // Autoplay loop
        if(this.autoSpinsRemaining>0){
          this.autoSpinsRemaining--; if(this.autoSpinsRemaining===0){ this.$('auto').textContent='🔄 AUTO'; }
          setTimeout(()=> this.trySpin(), 800);
        } else {
          this.$('auto').textContent = this.autoSpinsRemaining>0 ? '⏹️ STOP AUTO' : '🔄 AUTO';
        }
      }

      evaluateLine(lineSyms){
        // Handle wild ⭐ substitutions for best 3-of-a-kind
        // Count by symbol ignoring specials
        const isSpecial = (s)=> (s==='🎁'||s==='🆓');
        const base = lineSyms.filter(s=> s!=='⭐' && !isSpecial(s));
        if(base.length===0) return { amount: 0 };
        // Pick the most frequent base symbol
        const counts = {}; base.forEach(s=> counts[s]=(counts[s]||0)+1);
        let target = Object.keys(counts).sort((a,b)=> counts[b]-counts[a])[0];
        // Compose with wilds
        const totalCount = counts[target] + lineSyms.filter(s=>s==='⭐').length;
        if(totalCount<3) return { amount: 0 };

        const symData = this.symbols.find(x=> x.char===target);
        if(!symData) return { amount: 0 };
        const amount = symData.pay3; // 3-of-kind on 3-reel game
        const jackpot = (target==='👑' && totalCount===3); // 3 crowns
        return { amount, kind: target, jackpot };
      }

      // Visual helpers
      overlayWin(text){
        const w=this.$('winOverlay'); this.$('winText').textContent = text; w.style.display='flex';
        setTimeout(()=> w.style.display='none', 2200);
      }
      overlayJackpot(){ const j=this.$('jackpot'); j.style.display='flex'; setTimeout(()=> j.style.display='none', 3200); }
      flashPaylines(on){ ['payTop','payMid','payBot','payD1','payD2'].forEach(id=> this.$(id).style.opacity = on? '1':'0'); }
      touchRipple(el, e){ const r=document.createElement('div'); r.className='touch-ripple'; const rect=el.getBoundingClientRect(); const x=e.clientX-rect.left-30, y=e.clientY-rect.top-30; r.style.left=x+'px'; r.style.top=y+'px'; el.appendChild(r); setTimeout(()=> r.remove(), 650); }
      sparkles(el, e){ const rect=el.getBoundingClientRect(); for(let i=0;i<6;i++){ const s=document.createElement('div'); s.className='sparkle'; const x=e.clientX-rect.left+ (Math.random()-0.5)*120; const y=e.clientY-rect.top + (Math.random()-0.5)*120; s.style.left=x+'px'; s.style.top=y+'px'; el.appendChild(s); s.animate([{transform:'scale(0) rotate(0deg)',opacity:1},{transform:'scale(1) rotate(180deg)',opacity:1,offset:.5},{transform:'scale(0) rotate(360deg)',opacity:0}],{duration:820,easing:'ease-out'}).onfinish=()=> s.remove(); } }
      coinRain(n){ const el=this.$('topScreen'); for(let i=0;i<n;i++){ setTimeout(()=>{ const c=document.createElement('div'); c.style.cssText='position:absolute;width:20px;height:20px;border-radius:50%;background:radial-gradient(circle,#ffd700,#ffec80);border:2px solid #f1c40f;box-shadow:0 0 12px rgba(255,215,0,.65);z-index:7;'; const x=Math.random()*el.clientWidth; const y=el.clientHeight*0.25; c.style.left=x+'px'; c.style.top=y+'px'; el.appendChild(c); c.animate([{transform:'translateY(0) rotate(0deg) scale(0)',opacity:1},{transform:`translateY(${el.clientHeight*0.6}px) rotate(720deg) scale(1)`,opacity:1,offset:.8},{transform:`translateY(${el.clientHeight*0.7}px) rotate(900deg) scale(0)`,opacity:0}],{duration:1400+Math.random()*500,easing:'cubic-bezier(.25,.46,.45,.94)'}).onfinish=()=> c.remove(); }, i*90); } }

      // LEDs
      seedLEDs(){ const grid=this.$('ledGrid'); const cols=24, rows=4; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ const d=document.createElement('div'); d.className='led'; grid.appendChild(d); } } }

      // Paytable UI
      renderPaytable(){
        const g=this.$('paytableGrid'); g.innerHTML='';
        const nice = (n)=> '$'+n.toLocaleString();
        this.symbols.forEach(s=>{
          if(s.bonus||s.freespin) return; // list specials separately below
          const row=document.createElement('div'); row.className='pt-row';
          const left=document.createElement('div'); left.className='pt-sym'; left.textContent=s.char;
          const right=document.createElement('div'); right.className='pt-pay'; right.innerHTML = `3x: <span style="color:#ffef9a;font-weight:900;">${nice(s.pay3)}</span>`;
          row.appendChild(left); row.appendChild(right); g.appendChild(row);
        });
        const bonus=document.createElement('div'); bonus.className='pt-row'; bonus.innerHTML='<div class="pt-sym">🎁</div><div class="pt-pay">3x anywhere: BONUS (instant award)</div>';
        const fs=document.createElement('div'); fs.className='pt-row'; fs.innerHTML='<div class="pt-sym">🆓</div><div class="pt-pay">3x anywhere: 8 Free Spins @2x</div>';
        const wild=document.createElement('div'); wild.className='pt-row'; wild.innerHTML='<div class="pt-sym">⭐</div><div class="pt-pay">WILD substitutes best line</div>';
        g.appendChild(bonus); g.appendChild(fs); g.appendChild(wild);
      }
      showPaytable(show){ this.$('paytableModal').style.display = show? 'flex':'none'; }

      // Utils
      delay(ms){ return new Promise(r=> setTimeout(r, ms)); }
      toast(text){
        const d=document.createElement('div'); d.textContent=text; d.style.cssText='position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 16px;background:rgba(0,0,0,0.85);border:2px solid #ffcf40;border-radius:12px;color:#ffef9a;font-weight:800;z-index:1000;box-shadow:0 0 20px rgba(255,215,0,.35);text-align:center;';
        document.body.appendChild(d); setTimeout(()=> d.remove(), 1800);
      }
      play(name){ const fn=this.sounds[name]; if(fn) fn(); }
    }

    // Boot
    window.addEventListener('DOMContentLoaded', ()=> new NeonCrownRoyale());

    // Simple CSS-driven spin animation (class toggled)
    const style = document.createElement('style');
    style.textContent = `
      .spinning { animation: reelSpin .12s linear infinite; }
      @keyframes reelSpin { from { transform: translateY(0); } to { transform: translateY(-86px); } }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
