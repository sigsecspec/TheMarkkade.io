<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#00FFFF" />
<title>Cyber Slots 2088 - Neon Grid</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
  
  body {
    background: #000;
    color: #00FFFF;
    font-family: 'Orbitron', monospace;
    user-select: none;
    overflow: hidden;
    position: relative;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
  }

  /* Cyberpunk grid background */
  .cyber-grid {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      linear-gradient(180deg, #000 0%, #0a0a2e 50%, #000 100%);
    z-index: -3;
  }

  .cyber-grid::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background-image: 
      linear-gradient(0deg, transparent 24%, rgba(0, 255, 255, 0.05) 25%, rgba(0, 255, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(0, 255, 255, 0.05) 75%, rgba(0, 255, 255, 0.05) 76%, transparent 77%, transparent),
      linear-gradient(90deg, transparent 24%, rgba(255, 0, 255, 0.05) 25%, rgba(255, 0, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(255, 0, 255, 0.05) 75%, rgba(255, 0, 255, 0.05) 76%, transparent 77%, transparent);
    background-size: 50px 50px;
    animation: gridMove 10s linear infinite;
  }

  @keyframes gridMove {
    0% { transform: translate(0, 0); }
    100% { transform: translate(50px, 50px); }
  }

  /* Neon scanlines */
  .scanlines {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      transparent 50%,
      rgba(0, 255, 255, 0.03) 50%
    );
    background-size: 100% 4px;
    pointer-events: none;
    z-index: 2;
    animation: scanline 8s linear infinite;
  }

  @keyframes scanline {
    0% { transform: translateY(0); }
    100% { transform: translateY(10px); }
  }

  /* Glitch effect */
  @keyframes glitch {
    0%, 100% { 
      text-shadow: 
        2px 0 #FF00FF,
        -2px 0 #00FFFF,
        0 0 20px #FF00FF,
        0 0 40px #00FFFF;
    }
    25% { 
      text-shadow: 
        -2px 0 #FF00FF,
        2px 0 #00FFFF,
        0 0 30px #00FFFF,
        0 0 50px #FF00FF;
    }
    50% {
      text-shadow: 
        2px 2px #FF00FF,
        -2px -2px #00FFFF,
        0 0 35px #FF00FF,
        0 0 45px #00FFFF;
    }
  }

  /* Neon border frame */
  .neon-frame {
    position: fixed;
    top: 10px;
    left: 10px;
    right: 10px;
    bottom: 10px;
    border: 2px solid #00FFFF;
    border-radius: 0;
    pointer-events: none;
    z-index: 10;
    box-shadow: 
      0 0 20px #00FFFF,
      inset 0 0 20px rgba(0, 255, 255, 0.2),
      0 0 40px #FF00FF,
      inset 0 0 40px rgba(255, 0, 255, 0.1);
    animation: neonPulse 2s ease-in-out infinite;
  }

  @keyframes neonPulse {
    0%, 100% { 
      box-shadow: 
        0 0 20px #00FFFF,
        inset 0 0 20px rgba(0, 255, 255, 0.2);
    }
    50% { 
      box-shadow: 
        0 0 40px #FF00FF,
        inset 0 0 40px rgba(255, 0, 255, 0.3);
    }
  }

  .game-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 1;
  }
  
  .fold-top {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 16px;
    background: 
      linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(10, 10, 46, 0.6) 100%);
    border-bottom: 2px solid #00FFFF;
    position: relative;
    overflow: hidden;
  }

  /* Holographic display effect */
  .holo-display {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 255, 255, 0.03) 2px,
        rgba(0, 255, 255, 0.03) 4px
      );
    pointer-events: none;
    animation: holoScan 4s linear infinite;
  }

  @keyframes holoScan {
    0% { transform: translateY(0); }
    100% { transform: translateY(20px); }
  }

  h1 {
    text-align: center;
    color: #00FFFF;
    font-size: clamp(1.8rem, 6vw, 3rem);
    font-weight: 900;
    letter-spacing: 6px;
    text-transform: uppercase;
    text-shadow: 
      0 0 20px #00FFFF,
      0 0 40px #00FFFF,
      0 0 60px #FF00FF,
      2px 2px 0 #FF00FF;
    position: relative;
    z-index: 1;
    font-family: 'Orbitron', monospace;
    animation: glitch 3s infinite;
    padding: 15px 30px;
    border: 2px solid #00FFFF;
    background: rgba(0, 0, 0, 0.8);
    clip-path: polygon(0 0, 100% 0, 100% 75%, 85% 100%, 0 100%);
  }

  h1::before {
    content: 'CYBER SLOTS 2088';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    color: #FF00FF;
    z-index: -1;
    animation: glitchText 0.3s infinite;
    padding: 15px 30px;
  }

  @keyframes glitchText {
    0% { left: 0; }
    25% { left: -2px; }
    50% { left: 2px; }
    75% { left: -1px; }
    100% { left: 0; }
  }

  .game-stats {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    justify-content: center;
    width: 100%;
    max-width: 600px;
    z-index: 1;
  }
  
  #walletDisplay, #freeSpinCounter {
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00FFFF;
    border-radius: 0;
    padding: 12px 20px;
    box-shadow: 
      0 0 20px rgba(0, 255, 255, 0.5),
      inset 0 0 10px rgba(0, 255, 255, 0.2);
    color: #00FFFF;
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: 2px;
    text-align: center;
    flex: 1;
    min-width: 180px;
    position: relative;
    text-transform: uppercase;
    text-shadow: 0 0 10px currentColor;
    clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
  }

  #walletDisplay::before {
    content: '₿';
    margin-right: 8px;
    font-size: 1.4rem;
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  #freeSpinCounter {
    border-color: #FF00FF;
    color: #FF00FF;
    display: none;
    box-shadow: 
      0 0 20px rgba(255, 0, 255, 0.5),
      inset 0 0 10px rgba(255, 0, 255, 0.2);
  }

  #freeSpinCounter::before {
    content: '⚡';
    margin-right: 8px;
    font-size: 1.4rem;
  }
  
  #slotContainer {
    position: relative;
    width: 100%;
    max-width: 480px;
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #00FFFF;
    border-radius: 0;
    padding: 20px;
    box-shadow: 
      0 0 40px rgba(0, 255, 255, 0.6),
      inset 0 0 20px rgba(0, 255, 255, 0.2),
      0 0 80px rgba(255, 0, 255, 0.3);
    z-index: 1;
    clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
  }

  #slotContainer::before {
    content: 'MATRIX';
    position: absolute;
    top: 5px;
    left: 10px;
    color: #00FFFF;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 3px;
    opacity: 0.5;
  }

  #slotContainer::after {
    content: 'v2.088';
    position: absolute;
    top: 5px;
    right: 10px;
    color: #FF00FF;
    font-size: 0.7rem;
    font-weight: 700;
    opacity: 0.5;
  }
  
  #slotGrid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    position: relative;
    z-index: 1;
    margin-top: 15px;
  }
  
  .slotCell {
    background: 
      linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.05) 100%),
      rgba(0, 0, 0, 0.9);
    border: 2px solid #00FFFF;
    border-radius: 0;
    font-size: clamp(2.5rem, 7vw, 3.5rem);
    text-align: center;
    box-shadow: 
      0 0 15px rgba(0, 255, 255, 0.4),
      inset 0 0 10px rgba(0, 255, 255, 0.2);
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: all 0.3s ease;
    overflow: hidden;
    clip-path: polygon(15% 0, 100% 0, 100% 85%, 85% 100%, 0 100%, 0 15%);
  }

  .slotCell::before {
    content: '';
    position: absolute;
    top: -100%;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, transparent 0%, rgba(0, 255, 255, 0.3) 50%, transparent 100%);
    animation: dataStream 2s linear infinite;
  }

  @keyframes dataStream {
    0% { top: -100%; }
    100% { top: 100%; }
  }

  .slotCell.spinning {
    animation: cyberSpin 0.1s linear infinite;
    border-color: #FF00FF;
    box-shadow: 
      0 0 30px rgba(255, 0, 255, 0.8),
      inset 0 0 20px rgba(255, 0, 255, 0.4);
  }

  @keyframes cyberSpin {
    0% { 
      transform: rotateX(0deg);
      filter: hue-rotate(0deg);
    }
    100% { 
      transform: rotateX(360deg);
      filter: hue-rotate(360deg);
    }
  }
  
  .winning {
    background: 
      linear-gradient(135deg, #00FFFF 0%, #FF00FF 100%);
    border-color: #FFFFFF;
    box-shadow: 
      0 0 50px rgba(255, 255, 255, 0.9),
      0 0 100px rgba(0, 255, 255, 0.7),
      inset 0 0 30px rgba(255, 255, 255, 0.5);
    animation: cyberWin 0.3s ease-in-out infinite alternate;
    z-index: 10;
  }

  @keyframes cyberWin {
    0% { 
      transform: scale(1);
      filter: brightness(1.5) saturate(2);
    }
    100% { 
      transform: scale(1.1);
      filter: brightness(2) saturate(3);
    }
  }
  
  #linesSvg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2;
  }

  .winLine {
    stroke: #00FFFF;
    stroke-width: 4;
    stroke-linecap: round;
    opacity: 1;
    filter: drop-shadow(0 0 10px #00FFFF);
    stroke-dasharray: 5, 5;
    animation: neonLineFlow 0.5s linear infinite;
  }
  
  @keyframes neonLineFlow {
    0% { 
      stroke-dashoffset: 0;
      stroke: #00FFFF;
    }
    50% {
      stroke: #FF00FF;
    }
    100% { 
      stroke-dashoffset: 10;
      stroke: #00FFFF;
    }
  }

  #message {
    text-align: center;
    font-size: 1.1rem;
    min-height: 2.5em;
    color: #00FFFF;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00FFFF;
    border-radius: 0;
    padding: 12px 20px;
    box-shadow: 
      0 0 20px rgba(0, 255, 255, 0.5),
      inset 0 0 10px rgba(0, 255, 255, 0.2);
    font-weight: 700;
    letter-spacing: 2px;
    max-width: 600px;
    text-shadow: 0 0 10px currentColor;
    text-transform: uppercase;
    z-index: 1;
    clip-path: polygon(20px 0, 100% 0, 100% 100%, 0 100%, 0 20px);
    animation: messageGlow 2s ease-in-out infinite;
  }

  @keyframes messageGlow {
    0%, 100% { border-color: #00FFFF; }
    50% { border-color: #FF00FF; }
  }
  
  .fold-bottom {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    padding: 20px;
    background: 
      linear-gradient(180deg, rgba(10, 10, 46, 0.6) 0%, rgba(0, 0, 0, 0.9) 100%);
    position: relative;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  #betSelector {
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #00FFFF;
    border-radius: 0;
    padding: 15px;
    box-shadow: 
      0 0 30px rgba(0, 255, 255, 0.4),
      inset 0 0 15px rgba(0, 255, 255, 0.2);
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    width: 100%;
    max-width: 600px;
    clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 0 100%);
  }
  
  #betSelector button {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #00FFFF;
    color: #00FFFF;
    padding: 12px;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    border-radius: 0;
    font-family: 'Orbitron', monospace;
    letter-spacing: 1px;
    box-shadow: 
      0 0 15px rgba(0, 255, 255, 0.3),
      inset 0 0 10px rgba(0, 255, 255, 0.1);
    min-height: 50px;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px currentColor;
    position: relative;
    overflow: hidden;
    clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
  }

  #betSelector button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.4), transparent);
    transition: left 0.5s;
  }

  #betSelector button:hover::before {
    left: 100%;
  }

  #betSelector button:hover {
    border-color: #FF00FF;
    color: #FF00FF;
    transform: translateY(-2px);
    box-shadow: 
      0 0 25px rgba(255, 0, 255, 0.5),
      inset 0 0 15px rgba(255, 0, 255, 0.2);
  }

  #betSelector button:active {
    transform: translateY(0);
  }

  #betSelector button.selected {
    background: 
      linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.2) 100%);
    color: #FFFFFF;
    border-color: #FFFFFF;
    box-shadow: 
      0 0 40px rgba(255, 255, 255, 0.6),
      inset 0 0 20px rgba(255, 255, 255, 0.3);
    animation: selectedGlow 1s ease-in-out infinite;
  }

  @keyframes selectedGlow {
    0%, 100% { 
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.6),
        inset 0 0 20px rgba(0, 255, 255, 0.3);
    }
    50% { 
      box-shadow: 
        0 0 40px rgba(255, 0, 255, 0.6),
        inset 0 0 20px rgba(255, 0, 255, 0.3);
    }
  }

  .action-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
    width: 100%;
    max-width: 600px;
  }

  .action-buttons button {
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00FFFF;
    color: #00FFFF;
    padding: 10px;
    font-weight: 700;
    font-size: 0.9rem;
    cursor: pointer;
    border-radius: 0;
    font-family: 'Orbitron', monospace;
    letter-spacing: 1px;
    box-shadow: 
      0 0 15px rgba(0, 255, 255, 0.3),
      inset 0 0 10px rgba(0, 255, 255, 0.1);
    min-height: 45px;
    transition: all 0.3s ease;
    text-shadow: 0 0 5px currentColor;
    text-transform: uppercase;
    clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 10px 100%, 0 calc(100% - 10px));
  }

  .action-buttons button:hover {
    border-color: #FF00FF;
    color: #FF00FF;
    box-shadow: 
      0 0 25px rgba(255, 0, 255, 0.5),
      inset 0 0 15px rgba(255, 0, 255, 0.2);
  }

  .action-buttons button:active {
    transform: scale(0.95);
  }

  #autoSpinBtn[data-running="true"] {
    background: rgba(255, 0, 0, 0.2);
    border-color: #FF0066;
    color: #FF0066;
    animation: autoRunning 1s ease-in-out infinite;
  }

  @keyframes autoRunning {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  #spinBtn {
    background: 
      linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.1) 100%),
      rgba(0, 0, 0, 0.95);
    color: #00FFFF;
    font-weight: 900;
    font-size: 1.8rem;
    padding: 20px 40px;
    border: 3px solid #00FFFF;
    border-radius: 0;
    cursor: pointer;
    box-shadow: 
      0 0 50px rgba(0, 255, 255, 0.6),
      inset 0 0 30px rgba(0, 255, 255, 0.3);
    letter-spacing: 4px;
    min-width: 250px;
    text-shadow: 
      0 0 20px currentColor,
      2px 2px 0 #FF00FF;
    font-family: 'Orbitron', monospace;
    text-transform: uppercase;
    position: relative;
    transition: all 0.3s ease;
    grid-column: 1 / -1;
    overflow: hidden;
    clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
    animation: spinBtnPulse 2s ease-in-out infinite;
  }

  @keyframes spinBtnPulse {
    0%, 100% { 
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.6),
        inset 0 0 30px rgba(0, 255, 255, 0.3);
    }
    50% { 
      box-shadow: 
        0 0 70px rgba(255, 0, 255, 0.7),
        inset 0 0 40px rgba(255, 0, 255, 0.4);
    }
  }

  #spinBtn::before {
    content: '';
    position: absolute;
    top: -100%;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: spinBtnScan 3s linear infinite;
  }

  @keyframes spinBtnScan {
    0% { top: -100%; }
    100% { top: 100%; }
  }

  #spinBtn:hover {
    transform: scale(1.05);
    border-color: #FF00FF;
    color: #FF00FF;
    box-shadow: 
      0 0 80px rgba(255, 0, 255, 0.8),
      inset 0 0 50px rgba(255, 0, 255, 0.5);
  }

  #spinBtn:active {
    transform: scale(0.98);
  }
  
  #spinBtn:disabled {
    background: rgba(50, 50, 50, 0.5);
    color: rgba(100, 100, 100, 0.5);
    cursor: not-allowed;
    border-color: rgba(100, 100, 100, 0.3);
    box-shadow: none;
    animation: none;
  }

  /* Mobile/Razr optimizations */
  @media (max-width: 480px) {
    h1 {
      font-size: 1.3rem;
      letter-spacing: 3px;
      padding: 10px 20px;
    }

    .slotCell {
      font-size: 2.2rem;
    }

    #spinBtn {
      font-size: 1.3rem;
      padding: 15px 30px;
      letter-spacing: 2px;
    }
  }
</style>
</head>
<body>

<div class="cyber-grid"></div>
<div class="scanlines"></div>
<div class="neon-frame"></div>

<div class="game-container">
  <div class="fold-top">
    <div class="holo-display"></div>
    <h1>CYBER SLOTS 2088</h1>
    
    <div class="game-stats">
      <div id="walletDisplay">CREDITS: 0</div>
      <div id="freeSpinCounter">POWER-UPS: 0</div>
    </div>
    
    <div id="slotContainer">
      <div id="slotGrid"></div>
      <svg id="linesSvg"></svg>
    </div>
    
    <div id="message">INITIALIZE MATRIX</div>
  </div>

  <div class="fold-bottom">
    <div id="betSelector">
      <button data-bet="10" class="selected">¢10</button>
      <button data-bet="20">¢20</button>
      <button data-bet="30">¢30</button>
      <button data-bet="40">¢40</button>
      <button data-bet="50">¢50</button>
    </div>

    <div class="action-buttons">
      <button id="spinBtn">JACK IN</button>
      <button id="autoSpinBtn" data-running="false">AUTO</button>
      <button id="maxBetBtn">MAX</button>
      <button id="leaveGameBtn">EXIT</button>
    </div>
  </div>
</div>

<script>
(function() {
  const rows = 3, cols = 5;

  // Cyberpunk themed symbols
  const symbols = [
    { sym: "🤖", name: "Android" },
    { sym: "👾", name: "Alien" },
    { sym: "🎮", name: "Controller" },
    { sym: "💻", name: "Terminal" },
    { sym: "🔮", name: "Data Core" },
    { sym: "⚡", name: "Power Surge" },
    { sym: "🌐", name: "Network" },
    { sym: "🔥", name: "Firewall" }
  ];

  // Balanced weights for cyberpunk theme
  const weights = {
    "🤖": 18, "👾": 16, "🎮": 14, "💻": 12,
    "🔮": 10, "⚡": 12, "🌐": 10, "🔥": 8
  };

  // Cyberpunk payouts (credits system)
  const payouts = {
    "🔥": { 10: [500, 1500, 3000], 20: [1000, 3000, 6000], 30: [1500, 4500, 9000], 40: [2000, 6000, 12000], 50: [2500, 7500, 15000] },
    "🌐": { 10: [100, 300, 600], 20: [200, 600, 1200], 30: [300, 900, 1800], 40: [400, 1200, 2400], 50: [500, 1500, 3000] },
    "⚡": { 10: [50, 150, 300], 20: [100, 300, 600], 30: [150, 450, 900], 40: [200, 600, 1200], 50: [250, 750, 1500] },
    "🔮": { 10: [75, 225, 450], 20: [150, 450, 900], 30: [225, 675, 1350], 40: [300, 900, 1800], 50: [375, 1125, 2250] },
    "💻": { 10: [40, 120, 240], 20: [80, 240, 480], 30: [120, 360, 720], 40: [160, 480, 960], 50: [200, 600, 1200] },
    "🎮": { 10: [30, 90, 180], 20: [60, 180, 360], 30: [90, 270, 540], 40: [120, 360, 720], 50: [150, 450, 900] },
    "👾": { 10: [20, 60, 120], 20: [40, 120, 240], 30: [60, 180, 360], 40: [80, 240, 480], 50: [100, 300, 600] },
    "🤖": { 10: [15, 45, 90], 20: [30, 90, 180], 30: [45, 135, 270], 40: [60, 180, 360], 50: [75, 225, 450] }
  };

  const freeSpinsAward = { 3: 15, 4: 30, 5: 75 }; // Firewall triggers power-ups

  // Cyberpunk Sound System
  let audioContext = null;

  function initAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    return audioContext;
  }

  function playSound(type) {
    try {
      const ctx = initAudio();
      const now = ctx.currentTime;
      
      if (type === 'spin') {
        // Digital initialization sound
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, now);
        filter.frequency.exponentialRampToValueAtTime(2000, now + 0.2);
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(50, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.2);
        
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.start(now);
        osc.stop(now + 0.3);

        // Add glitch sounds
        for (let i = 0; i < 5; i++) {
          const glitch = ctx.createOscillator();
          const glitchGain = ctx.createGain();
          glitch.connect(glitchGain);
          glitchGain.connect(ctx.destination);
          
          glitch.frequency.value = Math.random() * 1000 + 500;
          glitch.type = 'square';
          glitchGain.gain.setValueAtTime(0.05, now + i * 0.05);
          glitchGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.02);
          
          glitch.start(now + i * 0.05);
          glitch.stop(now + i * 0.05 + 0.02);
        }
      } else if (type === 'reel_stop') {
        // Digital lock sound
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        osc.frequency.setValueAtTime(1000, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        osc.type = 'square';
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        osc.start(now);
        osc.stop(now + 0.15);
      } else if (type === 'win') {
        // Cyber victory sound
        const frequencies = [261, 329, 392, 523];
        frequencies.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const filter = ctx.createBiquadFilter();
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(ctx.destination);
          
          filter.type = 'bandpass';
          filter.frequency.value = freq * 2;
          
          osc.frequency.value = freq;
          osc.type = 'square';
          gain.gain.setValueAtTime(0.1, now + i * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.3);
          
          osc.start(now + i * 0.1);
          osc.stop(now + i * 0.1 + 0.3);
        });
      } else if (type === 'bigwin') {
        // Matrix breakthrough sound
        for (let i = 0; i < 8; i++) {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const panner = ctx.createStereoPanner();
          
          osc.connect(panner);
          panner.connect(gain);
          gain.connect(ctx.destination);
          
          panner.pan.value = Math.sin(i) * 0.8;
          
          osc.frequency.setValueAtTime(100 + i * 100, now + i * 0.05);
          osc.frequency.exponentialRampToValueAtTime(2000, now + i * 0.05 + 0.2);
          osc.type = 'sawtooth';
          
          gain.gain.setValueAtTime(0.2, now + i * 0.05);
          gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.4);
          
          osc.start(now + i * 0.05);
          osc.stop(now + i * 0.05 + 0.4);
        }
      } else if (type === 'button') {
        // Interface beep
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        osc.frequency.value = 800;
        osc.type = 'square';
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        
        osc.start(now);
        osc.stop(now + 0.05);
      }
    } catch (e) {
      console.log('Audio error:', e);
    }
  }

  // Initialize audio on user interaction
  document.addEventListener('click', () => initAudio(), { once: true });
  document.addEventListener('touchstart', () => initAudio(), { once: true });

  const walletDisplay = document.getElementById('walletDisplay');
  const betSelector = document.getElementById('betSelector');
  const spinBtn = document.getElementById('spinBtn');
  const autoSpinBtn = document.getElementById('autoSpinBtn');
  const maxBetBtn = document.getElementById('maxBetBtn');
  const slotGrid = document.getElementById('slotGrid');
  const linesSvg = document.getElementById('linesSvg');
  const messageEl = document.getElementById('message');
  const freeSpinCounterEl = document.getElementById('freeSpinCounter');
  const leaveGameBtn = document.getElementById('leaveGameBtn');

  let balance = Number(localStorage.getItem('localPlayerCash')) || 0;
  let freeSpins = Number(localStorage.getItem('freeSpins')) || 0;
  let bet = 10;
  let spinning = false;
  let autoSpinning = false;

  const cells = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.classList.add('slotCell');
      slotGrid.appendChild(cell);
      cells.push(cell);
    }
  }

  // Button sound effects
  document.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => playSound('button'));
  });

  function weightedRandomSymbol() {
    const totalWeight = Object.values(weights).reduce((a,b) => a+b, 0);
    let rnd = Math.random() * totalWeight;
    for (const sym of symbols) {
      rnd -= weights[sym.sym];
      if (rnd < 0) return sym.sym;
    }
    return symbols[0].sym;
  }

  function fillGridRandom() {
    const arr = [];
    for(let i=0; i<rows*cols; i++) {
      arr.push(weightedRandomSymbol());
    }
    return arr;
  }

  function renderGrid(arr) {
    for(let i=0; i < arr.length; i++) {
      cells[i].textContent = arr[i];
      cells[i].classList.remove('winning');
    }
  }

  function clearLines() {
    while(linesSvg.firstChild) linesSvg.removeChild(linesSvg.firstChild);
  }

  function drawWinLines(lines) {
    clearLines();
    const svgNS = "http://www.w3.org/2000/svg";
    lines.forEach(lineCells => {
      if(lineCells.length < 2) return;
      for(let i=0; i < lineCells.length - 1; i++) {
        const fromCell = cells[lineCells[i]];
        const toCell = cells[lineCells[i+1]];
        const fromRect = fromCell.getBoundingClientRect();
        const toRect = toCell.getBoundingClientRect();
        const svgRect = linesSvg.getBoundingClientRect();
        const x1 = fromRect.left + fromRect.width/2 - svgRect.left;
        const y1 = fromRect.top + fromRect.height/2 - svgRect.top;
        const x2 = toRect.left + toRect.width/2 - svgRect.left;
        const y2 = toRect.top + toRect.height/2 - svgRect.top;
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.classList.add('winLine');
        linesSvg.appendChild(line);
      }
    });
  }

  function highlightWinningCells(winIndices) {
    winIndices.forEach(i => cells[i].classList.add('winning'));
  }

  function findMatches(gridArr) {
    const matches = [];
    // Horizontal matches
    for(let r=0; r<rows; r++) {
      let streak = [r*cols];
      for(let c=1; c<cols; c++) {
        const currIdx = r*cols + c;
        const prevIdx = r*cols + c - 1;
        if (gridArr[currIdx] === gridArr[prevIdx] && isSymbolMatchable(gridArr[currIdx])) {
          streak.push(currIdx);
        } else {
          if(streak.length >= 3) matches.push([...streak]);
          streak = [currIdx];
        }
      }
      if(streak.length >= 3) matches.push([...streak]);
    }

    // Vertical matches
    for(let c=0; c<cols; c++) {
      let streak = [c];
      for(let r=1; r<rows; r++) {
        const currIdx = r*cols + c;
        const prevIdx = (r-1)*cols + c;
        if(gridArr[currIdx] === gridArr[prevIdx] && isSymbolMatchable(gridArr[currIdx])) {
          streak.push(currIdx);
        } else {
          if(streak.length >= 3) matches.push([...streak]);
          streak = [currIdx];
        }
      }
      if(streak.length >= 3) matches.push([...streak]);
    }

    return matches;
  }

  function isSymbolMatchable(sym) {
    return ["🤖", "👾", "🎮", "💻", "🔮", "⚡", "🌐", "🔥"].includes(sym);
  }

  function calculatePayout(matches, gridArr, bet) {
    let totalPayout = 0;
    let wildCount = 0;

    matches.forEach(group => {
      const sym = gridArr[group[0]];
      const count = group.length;
      if(payouts[sym] && payouts[sym][bet]) {
        const payoutArray = payouts[sym][bet];
        if(count >= 3 && count <= 5) {
          const payoutVal = payoutArray[count - 3];
          totalPayout += payoutVal;
        }
      }
    });

    // Firewall symbol triggers power-ups
    wildCount = gridArr.filter(s => s === "🔥").length;
    if(freeSpinsAward[wildCount]) {
      freeSpins += freeSpinsAward[wildCount];
      updateFreeSpinsDisplay();
      playSound('bigwin');
      showMessage(`⚡ POWER SURGE! +${freeSpinsAward[wildCount]} POWER-UPS ⚡`);
    }

    return totalPayout;
  }

  function showMessage(msg) {
    messageEl.textContent = msg;
  }

  function updateBalanceDisplay() {
    walletDisplay.textContent = `CREDITS: ${balance.toLocaleString()}`;
    localStorage.setItem('localPlayerCash', balance.toFixed(2));
  }

  function updateFreeSpinsDisplay() {
    if(freeSpins > 0) {
      freeSpinCounterEl.style.display = 'block';
      freeSpinCounterEl.textContent = `POWER-UPS: ${freeSpins}`;
    } else {
      freeSpinCounterEl.style.display = 'none';
    }
    localStorage.setItem('freeSpins', freeSpins);
  }

  async function spin() {
    if (spinning) return;
    spinning = true;
    clearLines();
    messageEl.textContent = '';

    const selectedBetBtn = betSelector.querySelector('button.selected');
    bet = Number(selectedBetBtn.dataset.bet);

    if (bet > balance && freeSpins === 0) {
      showMessage('INSUFFICIENT CREDITS');
      spinning = false;
      return;
    }

    spinBtn.disabled = true;

    if (freeSpins > 0) {
      freeSpins--;
      updateFreeSpinsDisplay();
      showMessage('⚡ POWER-UP ACTIVATED ⚡');
    } else {
      balance -= bet;
      updateBalanceDisplay();
      showMessage(`BET: ${bet} CREDITS`);
    }

    playSound('spin');

    const finalGrid = fillGridRandom();
    const spinDuration = 2000;
    const columnDelay = 150;

    // Spinning animation
    async function spinColumn(colIndex, duration) {
      const columnCells = [];
      for (let r = 0; r < rows; r++) {
        columnCells.push(cells[r * cols + colIndex]);
      }
      const startTime = performance.now();

      return new Promise(resolve => {
        function animate() {
          const now = performance.now();
          if (now - startTime >= duration) {
            for (let r = 0; r < rows; r++) {
              columnCells[r].textContent = finalGrid[r * cols + colIndex];
              columnCells[r].classList.remove('spinning');
            }
            resolve();
            return;
          }
          for (let r = 0; r < rows; r++) {
            columnCells[r].textContent = weightedRandomSymbol();
            columnCells[r].classList.add('spinning');
          }
          requestAnimationFrame(animate);
        }
        animate();
      });
    }

    const spinPromises = [];
    for (let col = 0; col < cols; col++) {
      await new Promise(r => setTimeout(r, columnDelay));
      spinPromises.push(spinColumn(col, spinDuration));
    }

    await Promise.all(spinPromises);

    // Stop sounds
    for (let i = 0; i < cols; i++) {
      setTimeout(() => playSound('reel_stop'), i * 100);
    }

    await new Promise(r => setTimeout(r, 500));

    renderGrid(finalGrid);
    const matches = findMatches(finalGrid);

    if (matches.length === 0) {
      showMessage('NO MATCH - TRY AGAIN');
    } else {
      const winIndices = matches.flat();
      highlightWinningCells(winIndices);
      drawWinLines(matches);
      const payout = calculatePayout(matches, finalGrid, bet);
      
      if (payout > 0) {
        balance += payout;
        updateBalanceDisplay();
        showMessage(`💰 WIN: ${payout.toLocaleString()} CREDITS 💰`);
        
        if (payout > bet * 20) {
          playSound('bigwin');
        } else {
          playSound('win');
        }
      }
    }

    spinning = false;
    spinBtn.disabled = false;
  }

  function setAutoSpinRunning(running) {
    autoSpinning = running;
    autoSpinBtn.dataset.running = running ? 'true' : 'false';
    autoSpinBtn.textContent = running ? 'STOP' : 'AUTO';
  }

  async function runAutoSpinLoop() {
    if (spinning || !autoSpinning) return;
    while (autoSpinning) {
      const selectedBetBtn = betSelector.querySelector('button.selected');
      const currentBet = Number(selectedBetBtn.dataset.bet);
      if (balance < currentBet && freeSpins === 0) {
        setAutoSpinRunning(false);
        showMessage('AUTO STOPPED - NO CREDITS');
        break;
      }
      await spin();
      await new Promise(r => setTimeout(r, 1000));
    }
  }

  autoSpinBtn.addEventListener('click', async () => {
    if (!autoSpinning) {
      setAutoSpinRunning(true);
      runAutoSpinLoop();
    } else {
      setAutoSpinRunning(false);
    }
  });

  maxBetBtn.addEventListener('click', () => {
    betSelector.querySelectorAll('button').forEach(b => {
      b.classList.remove('selected');
    });
    const maxBtn = betSelector.querySelector('button[data-bet="50"]');
    maxBtn.classList.add('selected');
    playSound('button');
    showMessage('MAX BET SELECTED');
  });

  leaveGameBtn.addEventListener('click', () => {
    localStorage.setItem('localPlayerCash', balance.toFixed(2));
    window.location.href = '../index.html';
  });

  betSelector.addEventListener('click', e => {
    if (e.target.tagName !== 'BUTTON') return;
    betSelector.querySelectorAll('button').forEach(b => {
      b.classList.remove('selected');
    });
    e.target.classList.add('selected');
  });

  spinBtn.addEventListener('click', spin);

  updateBalanceDisplay();
  updateFreeSpinsDisplay();
  renderGrid(fillGridRandom());
  showMessage('SYSTEM READY');

})();
</script>

</body>
</html>